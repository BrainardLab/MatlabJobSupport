function sshScriptFile = mjsWriteSshScript(job, varargin)
% Write a shell script that will invoke a given job via SSH and Docker.
%
% This saves us from having to write lots of SSH syntax by hand.
%
% sshScriptFile = mjsWriteSshScript(job) generates a shell script that will
% cause the job to be executed remotely, via SSH, in a Docker container.
%
% mjsExecuteSsh( ... 'dockerScriptFile', dockerScriptFile) specify the name
% of a "docker run" script that should be sent via SSH for remote
% execution, as generated by mjsWriteDockerRunScript().  The default is
% chosen based on the job name.
%
% mjsExecuteSsh( ... 'sshScriptFile', sshScriptFile) specify the name of
% the new SSH script that should be generated.  The default is chosen based
% on the dockerScriptFile.
%
% mjsExecuteSsh( ... 'host', host) specify the address or hostname of
% the remote host to access via SSH.
%
% mjsExecuteSsh( ... 'port', port) specify the port to connect to on the
% remote host.
%
% mjsExecuteSsh( ... 'user', user) specify the usename to use when
% connecting to the remote host.
%
% mjsExecuteSsh( ... 'identity', identity) specify the path to an
% identity file (often .pem) to use for authenticating with the remote
% host.
%
% mjsExecuteSsh( ... 'knownHostsFile', knownHostsFile) specify the path
% to the ssh "known_hosts" file, where the ssh key of the given host can be
% automatically accepted.  The default is '~/.ssh/known_hosts'.
%
% scriptFile = mjsWriteSshScript(varargin)
%
% 2016-2017 Brainard Lab, University of Pennsylvania

parser = inputParser();
parser.KeepUnmatched = true;
parser.addRequired('job', @isstruct);
parser.addParameter('dockerScriptFile', '', @ischar);
parser.addParameter('sshScriptFile', '', @ischar);
parser.addParameter('host', 'localhost', @ischar);
parser.addParameter('port', [], @isnumeric);
parser.addParameter('user', '', @ischar);
parser.addParameter('identity', '', @ischar);
parser.addParameter('knownHostsFile', '', @ischar);
parser.parse(job, varargin{:});
job = parser.Results.job;
dockerScriptFile = parser.Results.dockerScriptFile;
sshScriptFile = parser.Results.sshScriptFile;
host = parser.Results.host;
port = parser.Results.port;
user = parser.Results.user;
identity = parser.Results.identity;
knownHostsFile = parser.Results.knownHostsFile;

% default SSH user is current Matlab user
if isempty(user)
    [~, user] = system('whoami');
end

% default docker script name based on job name
if isempty(dockerScriptFile)
    dockerScriptFile = fullfile(tempdir(), 'mjs', 'scripts', [job.name '.sh']);
end

% default ssh script name based docker script name
if isempty(sshScriptFile)
    [sshPath, sshBase] = fileparts(dockerScriptFile);
    sshScriptFile = fullfile(sshPath, [sshBase '-ssh.sh']);
end

%% Make sure script dir exists.
scriptDir = fileparts(sshScriptFile);
if ~isempty(scriptDir) && 7 ~= exist(scriptDir, 'dir')
    mkdir(scriptDir);
end

fid = fopen(sshScriptFile, 'w');
if -1 == fid
    error('mjsWriteSshScript:fopen', ...
        'Could not open file <%s> for writing.', scriptFile);
end

try
    %% Shebang for predictable environment.
    fprintf(fid, '#!/bin/sh\n');
    
    
    %% Try to automatically accept the remote ssh key.
    %   avoids prompting the user to accept the key
    if ~isempty(knownHostsFile)
        fprintf(fid, 'ssh-keyscan -H "%s" >> "%s"\n', host, knownHostsFile);
    end
    
    
    %% Try to run the job script on the remote host.
    if isempty(port)
        portOption = '';
    else
        portOption = sprintf('-p %d', port);
    end
    
    if isempty(identity)
        idOption = '';
    else
        idOption = sprintf('-i "%s"', identity);
    end
    
    fprintf(fid, 'ssh %s %s \\\n', portOption, idOption);
    fprintf(fid, '  "%s@%s" \\\n', user, host);
    fprintf(fid, '  ''sh -s'' < "%s"\n', dockerScriptFile);
    
    fprintf(fid, '\n');
    
    fclose(fid);
    
catch err
    fclose(fid);
    rethrow(err);
end

system(['chmod +x ' sshScriptFile]);
